#ifndef SERVER_H
#define SERVER_H

/*!
 * \defgroup  interfaceModule Ethernet Interface Module.
 *
 * This Module implements the communication with the Can Clients.
 *
 *
 * # DEVICE DRIVER OVERVIEW
 *
 * This module implement a Server Socket TcpIp based communication,\n
 * in order to let Clients application to send data frames on the CAN network.
 *
 * The server allows the connection with multi clients at the address:
 *
 * - IP: 127.0.0.1 (local Host);
 * - PORT: 10001
 *
 * The Client that needs to send data into the CAN Network shall:
 * - Connect the server at the IP&PORT;
 * - Register the canId remote device address that needs to exchange data;
 * - Send and receive data to/fromthe targeted device.
 *
 * A Client can register as a broadcast client:
 * - The Broadcast Client receives ALL the CAN frames but cannot send data frame.
 *
 *
 * # PROTOCOL DESCRIPTION
 *
 *  There are two only command frames:
 *  - Client Registering data frame;
 *  - Can data frame;
 *
 *  Every frame is in ascii format so it can be easily monitored
 *
 *  ## CLIENT REGISTERING DATA FRAME FORMAT
 *
 *  The Register Data Frame format is:
 *
 *       <R canId>
 *  Where
 *  - '<' and '>' are frame delimiters
 *  - R: is the frame identifier;
 *  - canId: is the number of the CAN device address.
 *
 *
 *      NOTE: space characters are ignored for the frame syntax;
 *
 *  The canId format can be:
 *  - Decimal format: example, 1356;
 *  - Hexadecimal format: example, 0x1345
 *
 *  The registration workflow is:
 *  - Client sends <R canId>
 *  - Server answer replying the frame: <R canId>
 *
 *
 *      NOTE: only one canId can be registered per Client.
 *      In case more than one Register command should be received,
 *      only the last one will be valid.
 *
 *  ## CAN DATA FRAME FORMAT
 *
 *  The CAN Data Frame format is:
 *
 *       <C B0 B1 .. B7>
 *  Where
 *  - '<' and '>' are frame delimiters
 *  - C: is the frame identifier;
 *  - B0 to B7: are unsigned char can data content.
 *
 *
 *      NOTE: space characters are ignored for the frame syntax;
 *      NOTE: the data lenght can be lower than 8. In this case
 *      the can frame is filled with 0;
 *      NOTE: if the data lenght should be greater than 8, the data will be truncated to 8.
 *
 *  The can data content B0 to B7 can be of the following format:
 *  - Decimal format: example, 125;
 *  - Hexadecimal format: example, 0xCC
 *
 *
 *      NOTE: the server will forward the B0:B7 bytes to the device
 *      target ID equal to the canId registered for that Client.
 *
 *
 */

#include <QObject>

#include <QTcpServer>
#include <QTcpSocket>
#include <QHostAddress>
#include <QNetworkInterface>



/**
 * @brief This is the Client socket class
 *
 * For every  Connected Client the Application creates
 * an item of this class, handling the data exchange from
 * the client and the application.
 *
 *
 * \ingroup interfaceModule
 */
class SocketItem: public QObject
{
     Q_OBJECT

public:

    explicit SocketItem(){};
    ~SocketItem(){};

signals:
    void itemDisconnected(ushort id); //!< Signal of the client disconnection event
    void sendToCan(ushort canId, QByteArray dataFrame);//!< Signal generated by the Client socket to send data to the can driver
    void sendToClient(QByteArray data);//!< Signal to send data to the TcpIp socket for data transmission to CLient

public slots:

    void disconnected(); //!< Socket disconnection event slot
    void socketError(QAbstractSocket::SocketError error);//!< Socket error event slot
    void socketRxData();//!< Socket data received event slot
    void socketTxData(QByteArray);//!< Socket data to be transmitted

public:
    QTcpSocket* socket;//!< Pointer to the socket;
    ushort id;          //!< Identifier of the client
    ushort canId;       //!< canId registered for the client

private:
    void handleSocketFrame(QByteArray* data);//!< Ethernet frame decoding function
};

/**
 * @brief This class handle the whole set of connected clients
 *
 * The class handle the queue of the connected class;
 *
 * The class forwards the received can frame to the Client
 * registered with the address of the Can frame sender;
 *
 * The class is responsible to erase a disconnected client socket.
 *
 * \ingroup interfaceModule
 */
class Server : public QTcpServer
{
    Q_OBJECT

public:

    explicit Server(QString ipaddress, int port);
    ~Server();

    static const long _DEFAULT_TX_TIMEOUT = 5000;    //!< Default timeout in ms for tx data
    bool Start(void);   //! Starts listening the server on the IP&Port


signals:
    void sendToCan(ushort canId, QByteArray dataFrame);//!< Signal that shall be connected too the canDriver in order to actually send data to CAN

public slots:
    void disconnected(ushort id); //!< Disconnection slot coming from the internal socket
    void receivedCanFrame(ushort canId, QByteArray data); //!< Slot to be connected to the canDriver reception signal
    void sendToCanSlot(ushort canId, QByteArray dataFrame); //!< Slot connected to the internal socket to send tata to the canDriver


protected:
    void incomingConnection(qintptr socketDescriptor) override; //!< Incoming connection slot


private:

    QList<SocketItem*>   socketList;    //!< List of Sockets
    QHostAddress        localip;       //!< Address of the local server
    quint16             localport;     //!< Port of the local server
    ushort              idseq;
};


#endif // SERVER_H
