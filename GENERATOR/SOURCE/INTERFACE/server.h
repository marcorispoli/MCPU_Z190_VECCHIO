#ifndef SERVER_H
#define SERVER_H

#include "Typedef.h"

/*!
 * \defgroup  InterfaceModule Gantry Interface Module.
 *
 * This Module implements the communication protocol with the Gantry.
 *
 * # CONNECTION DETAILS
 *
 * The Server IP address is: 127.0.0.1@10002.
 *
 * More than one connection can be established at the same time:
 *  - Every connected client is linked to a unique ID identifier;
 *  - The Application will acknowledge a command only to the Sender of the command;
 *  - Every internal EVENT will be forwarded to all the client connected.
 *
 *
 * # PROTOCOL DESCRIPTION
 *
 * The protocol is based on the scheme EVENT / ACK:
 * - The EVENT is a command frame;
 * - The ACK is the acknowledge frame to the EVENT frame.
 *
 * The EVENT Frame is the following:
 * - <E SEQ Command PARAM1 ... PARAMN>
 *      - SEQ: is an arbitrary sequence number set by the sender and acknowledge by the receiver;
 *
 * The ACK Frame is
 * - <A SEQ OK/NOK CODE>
 *      - SEQ: is the sequence number of the EVENT frame;
 *
 * The Application handles the EVENTS from Gantry in the command.cpp file;
 *
 * The Application handles the EVENTS to Gantry in the event.cpp;
 *
 * # EVENTS FROM GANTRY DESCRIPTION
 *
 * The Events from Gantry are considered *Commands* to be executed;
 *
 * Follows the list of the Implemented Commands:
 *
 * - SetExposurePre(): Gantry sets the next Pre Exposure pulse data;
 * - SetExposurePulse(): Gantry sets the next Pulse Exposure data;
 * - SetTomoConfig(): Gantry sets the data for the next Tomo exposure;
 * - StartExposure(): Gantry starts the execution of the Exposure sequence;
 * - AbortExposure(): Gantry aborts the current executing exposure sequence;
 * - GetPostExposure(): Gantry requests the list of the pulses of the last exposure;
 *
 *  > The Application will acknowledge the command ONLY to the client that sent the command;
 *
 *
 * # EVENTS TO GANTRY DESCRIPTION
 *
 * The Events to Gantry are considered *Events* to be notified to the Gantry;
 *
 * Follows a list of the implemented Events:
 *
 * - EventMessage(): this is an "error" message generated by the Sedecal Generator;
 * - EventSetXrayEna(): this event notify the Gantry to activate/Deactivate the hardware signal XRAY-ENA;
 * - EventGetPulseData(): this event requests the Pulse data to the Gantry (AEC mode);
 * - EventXrayCompleted(): this event notifies Gantry about the Exposure complete event;
 * - EventStatus(): this event updates Gantry with the Sedecal Generator internal status;
 *
 *  > The Application will forward the EVENTS to all the connected clients.
 *
 */
#include <QObject>
#include <QTcpServer>
#include <QTcpSocket>
#include <QHostAddress>
#include <QNetworkInterface>


/**
 * @brief This Class implements a TcpIp Serve socket, running in a separate thread.
 *
 * The Class implements the basic routines to send and receive data from/to Gantry.
 *
 * \ingroup InterfaceModule
 */
class SocketItem: public QObject
{
     Q_OBJECT

public:

    explicit SocketItem(){};
    ~SocketItem(){};

signals:
    void itemDisconnected(ushort id); //!< Signal to inform the system about the communication status.
    void receivedCommandSgn(ushort id, QByteArray data); //!< For every decoded command received the server sends this signal to the Application.


public slots:
    void disconnected(); //!< Disconnection Callback received from the Socket Library
    void socketError(QAbstractSocket::SocketError error); //!< Error callback received from the Library
    void socketRxData(); //!< Data received callback received from the Socket Library
    void socketTxData(QByteArray);//!< Data to be sent to the Socket, received from the Application thread.

public:
    QTcpSocket* socket; //!< Socket pointer
    ushort id;  //!< Unique ID of the Connected Client
};

/**
 * @brief This class resides into the Main Thread and implements the
 * communication protocol with the Gantry.
 *
 * The class starts listening an incoming Client connection and creates\n
 * for any individual connection a given socket handler (SocketItem class). \n
 * Every Socket is assigned to a unique ID so that the Server can redirect the
 * answer frame with the sender client.
 *
 * The Reception and Transmission are implemented into the  QTcpServer library
 * that runs in a separate thread and exchanges data only through the SIgnal/Slot
 * mechanism.
 *
 *
 * \ingroup InterfaceModule
 */
class Server : public QTcpServer
{
    Q_OBJECT

public:

    explicit Server(QString ipaddress, int port);
    ~Server();

    static const long _DEFAULT_TX_TIMEOUT = 5000;    //!< Default timeout in ms for tx data
    bool Start(void); /// Starts the Server thread


signals:
    void txFrame(QByteArray data); /// This signal is Queued connected with the transmitting thread

public slots:
    void receivedCommandSlot(ushort id, QByteArray data); /// This is the slot handling the EVENTs from Gantry
    void disconnected(ushort id); /// Disconnect callback event of tyhe Socket thread


protected:
    void incomingConnection(qintptr socketDescriptor) override; //!< Incoming connection slot

public:

    // Lists of the event from Gantry
    void EventStatus(ushort seq);
    void EventMessage(ushort seq,QString msg);
    void EventSetXrayEna(ushort seq, bool state);
    void EventXrayCompleted(ushort seq, uchar code, float masPre, float masPulse, uchar error);
    void EventGetPulseData(ushort seq);

    // Lists of the event to Gantry
    QList<QString> SetExposurePre(QList<QString>* command);
    QList<QString> SetExposurePulse(QList<QString>* command);
    QList<QString> SetExposureTestPulse(QList<QString>* command);
    QList<QString> SetTomoConfig(QList<QString>* command);
    QList<QString> StartExposure(QList<QString>* command);
    QList<QString> AbortExposure(QList<QString>* command);
    QList<QString> GetPostExposure(QList<QString>* command);

private:

    QList<SocketItem*>  socketList;    //!< List of Sockets
    QHostAddress        localip;       //!< Address of the local server
    quint16             localport;     //!< Port of the local server
    ushort              idseq;         //!< Id counter, to assign a unique ID to a client

    void sendAck(ushort id, ushort seq, QList<QString>*  data);  //!< Helper function to send an Answer frame to Gantry
    void sendEvent(ushort seq, QList<QString>*  data);              //!< Helper function to send an EVENT frame to gantry
    QList<QString> getProtocolFrame(QByteArray* data);  //!< Extract the data content from a received frame

};


#endif // SERVER_H
