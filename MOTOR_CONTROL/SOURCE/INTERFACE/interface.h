#ifndef SERVER_H
#define SERVER_H


/*!
 * \defgroup  InterfaceModule Gantry Interface Module.
 *
 * This Module implements the communication protocol with the Gantry.
 *
 * # CONNECTION DETAILS
 *
 * The Server IP address is: 127.0.0.1@10003.
 *
 * More than one connection can be established at the same time:
 *  - Every connected client is linked to a unique ID identifier;
 *  - The Application will acknowledge a command only to the Sender of the command;
 *  - Every internal EVENT will be forwarded to all the client connected.
 *
 *
 * # PROTOCOL DESCRIPTION
 *
 * The protocol is based on the scheme EVENT / ACK:
 * - The EVENT is a command frame;
 * - The ACK is the acknowledge frame to the EVENT frame.
 *
 * The EVENT Frame is the following:
 * - <E SEQ Command PARAM1 ... PARAMN>
 *      - SEQ: is an arbitrary sequence number set by the sender and acknowledge by the receiver;
 *
 * The ACK Frame is
 * - <A SEQ OK/NOK CODE>
 *      - SEQ: is the sequence number of the EVENT frame;
 *
 * The Application handles the EVENTS from Gantry in the command.cpp file;
 *
 * The Application handles the EVENTS to Gantry in the event.cpp;
 *
 * # EVENTS FROM GANTRY DESCRIPTION
 *
 * The Events from Gantry are considered *Commands* to be executed;
 *
 * Follows the list of the Implemented Commands:
 *
 * - SetExposurePre(): Gantry sets the next Pre Exposure pulse data;
 *
 *  > The Application will acknowledge the command ONLY to the client that sent the command;
 *
 *
 * # EVENTS TO GANTRY DESCRIPTION
 *
 * The Events to Gantry are considered *Events* to be notified to the Gantry;
 *
 * Follows a list of the implemented Events:
 *
 * - EventMessage(): this is an "error" message generated by the Sedecal Generator;
 *
 *  > The Application will forward the EVENTS to all the connected clients.
 *
 */
#include <QObject>
#include <QTcpServer>
#include <QTcpSocket>
#include <QHostAddress>
#include <QNetworkInterface>


/**
 * @brief This Class implements a TcpIp Serve socket, running in a separate thread.
 *
 * The Class implements the basic routines to send and receive data from/to Gantry.
 *
 * \ingroup InterfaceModule
 */
class SocketItem: public QObject
{
     Q_OBJECT

public:

    explicit SocketItem(){};
    ~SocketItem(){};

signals:
    void itemDisconnected(ushort id); //!< Signal to inform the system about the communication status.
    void receivedCommandSgn(ushort id, QByteArray data); //!< For every decoded command received the server sends this signal to the Application.


public slots:
    void disconnected(); //!< Disconnection Callback received from the Socket Library
    void socketError(QAbstractSocket::SocketError error); //!< Error callback received from the Library
    void socketRxData(); //!< Data received callback received from the Socket Library
    void socketTxData(QByteArray);//!< Data to be sent to the Socket, received from the Application thread.

public:
    QTcpSocket* socket; //!< Socket pointer
    ushort id;  //!< Unique ID of the Connected Client
};

/**
 * @brief This class resides into the Main Thread and implements the
 * communication protocol with the Gantry.
 *
 * The class starts listening an incoming Client connection and creates\n
 * for any individual connection a given socket handler (SocketItem class). \n
 * Every Socket is assigned to a unique ID so that the Server can redirect the
 * answer frame with the sender client.
 *
 * The Reception and Transmission are implemented into the  QTcpServer library
 * that runs in a separate thread and exchanges data only through the SIgnal/Slot
 * mechanism.
 *
 *
 * \ingroup InterfaceModule
 */
class Interface : public QTcpServer
{
    Q_OBJECT

public:

    explicit Interface(QString ipaddress, int port);
    ~Interface();

    static const long _DEFAULT_TX_TIMEOUT = 5000;    //!< Default timeout in ms for tx data
    bool Start(void); /// Starts the Server thread


    _inline void configReceived(void){configuration.configuration_ok = true;}

signals:
    void txFrame(QByteArray data); /// This signal is Queued connected with the transmitting thread

public slots:
    void receivedCommandSlot(ushort id, QByteArray data); /// This is the slot handling the EVENTs from Gantry
    void disconnected(ushort id); /// Disconnect callback event of tyhe Socket thread


protected:
    void incomingConnection(qintptr socketDescriptor) override; //!< Incoming connection slot

private slots:
    void handleInterfaceStatus(void);

private:
    ushort wStatus;
    enum{
        _SYSTEM_CONFIGURATION = 0,
        _SYSTEM_RUNNING
    }interfaceStatus;

    struct{
        bool configuration_ok;
    }configuration;

    QList<SocketItem*>  socketList;    //!< List of Sockets
    QHostAddress        localip;       //!< Address of the local server
    quint16             localport;     //!< Port of the local server
    ushort              idseq;         //!< Id counter, to assign a unique ID to a client


    QList<QString> GetStatus(QList<QString>* command); //!< Gantry requests the current device status

    ushort handleInterfaceConfigurationStatus(void);
    ushort handleInterfaceRunningStatus(void);

};

#endif // SERVER_H
